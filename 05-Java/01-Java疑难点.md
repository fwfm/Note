## 1. 正确使用 equals（）方法  
调用`equals()`方法对象必须不为空，因而最好使用能确定一定不为空的对象来调用该方法。  

推荐最好使用`Objects.equals(obj1,obj2)`方法  可以避免触发空指针异常。  

**不能使用一个值为null的引用类型变量来调用非静态方法**，否则会抛出异常。

## 2. static 关键字  
- 修饰成员变量和成员方法:   

被`static`修饰的成员属于类，不属于单个这个类的某个对象，**被类中所有对象共享**，可以并且建议通过类名调用。  

- 静态代码块：   

定义在类中方法外, 静态代码块在非静态代码块之前执行。(静态代码块—>非静态代码块—>构造方法)。**该类不管创建多少对象，静态代码块只执行一次**。非静态代码块在每new一次就执行一次。 非静态代码块可在普通方法中定义(不过作用不大)；  

- 静态内部类（**static修饰类的话只能修饰内部类**）：  

 静态内部类与非静态内部类之间存在一个最大的区别:   
 **非静态内部类在编译完成之后会隐含地保存着一个引用**，该引用是指向创建它的外围类，但是静态内部类却没有。  
 
 没有这个引用就意味着：  
 1.它的创建是不需要依赖外围类的创建。  
 2.它不能使用任何外围类的非static成员变量和方法。  

 - 静态导包(用来**导入类中的静态资源**，1.5之后的新特性):   
 `import static` 这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法。

## 3. 使用 this 和 super 要注意的问题：  
- 在构造器中使用` super() `调用父类中的其他构造方法时，该语句必须处于构造器的首行，否则编译器会报错。  

- this 调用本类中的其他构造方法时，也要放在首行。 

- this、super不能用在static方法中。它们一个指向本类对象的引用，一个指向父类对象的引用，**都是属于对象范畴的东西，而静态方法是属于类范畴的东西**。

## 4. 反射机制介绍  
- JAVA 反射机制是在**运行状态中**，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 java 语言的反射机制。  

- 静态编译和动态编译  

  静态编译： 在编译时确定类型，绑定对象  

  动态编译： 运行时确定类型，绑定对象  

- 反射机制优缺点  

  优点： 运行期类型的判断，动态加载类，提高代码灵活度。  

  缺点： 1,性能瓶颈（反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的 java 代码要慢很多）  2,安全问题（动态操作改变类的属性）  

- 例子  

  1.使用 JDBC 连接数据库时使用 Class.forName()通过反射加载数据库的驱动程序；  

  2.Spring 框架的 IOC（动态加载管理 Bean）创建对象以及 AOP（动态代理）功能都和反射有联系；  

  3.动态配置实例的属性；

## 5.  有哪些集合是线程不安全的？怎么解决呢？  
我们常用的 `Arraylist` ,`LinkedList`,`Hashmap`,`HashSet`,`TreeSet`,`TreeMap`，`PriorityQueue` 都不是线程安全的。解决办法很简单，可以使用线程安全的集合来代替。

如果要使用线程安全的集合的话， `java.util.concurrent` 包中提供了很多并发容器供你使用：  

1.ConcurrentHashMap: 可以看作是线程安全的 HashMap  

2.CopyOnWriteArrayList:可以看作是线程安全的 ArrayList，在读多写少的场合性能非常好，远远好于 Vector.  

3.ConcurrentLinkedQueue:高效的并发队列，使用链表实现。可以看做一个线程安全的 LinkedList，这是一个非阻塞队列。  

## 6. RandomAccess 接口  
`RandomAccess `接口中什么都没有定义。所以，在我看来 `RandomAccess `接口不过是一个标识罢了。标识什么？ **标识实现这个接口的类具有随机访问功能**。

## 7. Java中的长度判断  
- `length` 属性 ：针对**数组**说的  

- length() 方法 ： 针对**字符串**说的  

- size()方法 ：针对**泛型集合**说的

## 8. comparable 和 Comparator 的区别  
- `comparable` 接口实际上是出自`java.lang`包 它有一个 `compareTo(Object obj)`方法用来排序  

- `comparator`接口实际上是出自 `java.util` 包它有一个`compare(Object obj1, Object obj2)`方法用来排序  

## 9. 无序性和不可重复性的含义是什么  
- 无序性：无序性不等于随机性 ，无序性是指存储的数据在底层数组中**并非按照数组索引的顺序添加** ，而是根据数据的**哈希值**决定的。  

- 不可重复性：添加的元素按照 `equals()`判断时 ，返回 false，需要同时重写` equals()`方法和 `hashCode()`方法。  

## 10. 比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同  
 `HashSet ` 是 Set 接口的主要实现类 ，HashSet 的底层是 HashMap，线程不安全的，可以存储 null 值；  

`LinkedHashSet` 是 HashSet 的子类，能够按照添加的顺序遍历；  

`TreeSet` 底层使用红黑树，能够按照添加元素的顺序进行遍历，排序的方式有自然排序和定制排序。  

## 11. HashMap 和 Hashtable 的区别  
- 线程是否安全：HashMap 是非线程安全的，HashTable 是线程安全的（加了同步锁）。  

- 效率：因为线程安全的问题，HashMap 要比 HashTable 效率高一点。（HashTable已被淘汰）  

- 对 Null key 和 Null value 的支持：HashMap 可以存储 null 的 key 和 value，HashTable 不允许有 null 键和 null 值。  

- 初始容量大小和每次扩充容量大小的不同 ：  
  * 不指定容量初始值：  
  Hashtable 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。  

    HashMap 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。  

  * 指定容量初始值：  
  Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为 2 的幂次方大小。  

## 12. HashMap 和 HashSet 区别  
HashSet 底层就是基于 HashMap 实现的。  

HashMap|HashSet  
-|-  
实现 Map 接口|实现 Set 接口  
存储键值对|仅存储对象  
使用`put()`方法添加元素|使用`add()`方法添加元素  
使用key计算hashCode|使用成员对象来计算 hashcode  

## 13. TreeMap 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力。  

## 14. 什么是快速失败(fail-fast)？  
快速失败(fail-fast) 是 Java 集合的一种**错误检测机制**。  
使用迭代器对集合进行遍历的时候，我们在多线程下操作非安全失败(fail-safe)的集合类可能就会触发 fail-fast 机制，导致抛出 ConcurrentModificationException 异常。 另外，在单线程下，如果在遍历过程中对集合对象的内容进行了修改的话也会触发 fail-fast 机制。  

## 15. 什么是安全失败(fail-safe)呢？  
在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。所以，在遍历过程中对原集合所作的修改并不能被迭代器检测到，故不会抛 ConcurrentModificationException 异常。  

## 16. 什么是上下文切换?  
处理多线程任务时，一个 CPU 核心在任意时刻只能被一个线程使
用，为了让这些线程都能得到有效执行，CPU 采取的策略是**为每个线程分配时间片并轮转的形式**。 当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。 （任务从保存到再加载的过程就是一次上下文切换。）  

## 17. 什么是线程死锁?如何避免死锁?  
概念：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。  

产生死锁的条件：  
- 互斥条件：该资源任意时刻只由一个线程占用。  

- 请求与保持条件：一个进程因请求资源被阻塞时，对已获得的资源保持不放。  

- 不剥夺条件：线程已获得的资源在未使用完之前不能被其它线程强行剥夺，只有自己使用完成后才释放资源。  

- 循环等待条件：若干进程间形成一种头尾相接的循环等待资源关系。  

避免死锁的方法：（同步代码块不要嵌套使用）  
- 破坏请求与保持条件：一次性申请所有资源。  

- 破坏不剥夺条件：占用部分资源的线程进一步申请其它资源时，如果申请不到就主动释放它占有的资源。  

- 破坏循环等待条件：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。  

## 18. `sleep()` 方法和 `wait()` 方法区别和共同点?   
- 两者都可以暂停线程的执行。  

- `sleep()`方法没有释放锁(死锁问题)，`wait()`方法释放了锁。  

- `sleep()`通常用于暂停执行，`wait()`通常用于线程间交互/通信（等待其它线程的执行结果）。  

- `sleep()`可以自动苏醒，而`wait()`必须通过`notify()`|`notifyAll()`方法苏醒。  

## 19. 为什么我们调用 `start()` 方法时会执行 `run()` 方法，为什么我们不能直接调用`run()`方法？  
new 一个 Thread，线程进入了新建状态;调用start() 方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 start() 会执行线程的相应准备工作，然后自动执行
run() 方法的内容，这是真正的多线程工作。 而直接执行run() 方法，会把 run 方法当成一个 main线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。  

**调用`start()`方法可以启动线程并使线程进入就绪状态，而run方法只是Thread的一个普通方法调用，还在主线程中执行。**  

## 20. 说一说自己对于` synchronized `关键字的了解   
` synchronized `关键字解决的是多线程之间访问资源同步性问题。它可以保证被它修饰的方法或代码块在任意时刻只能有一个线程执行。  

synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是是给 Class类上锁。  

synchronized 关键字加到实例方法上是给对象实例上锁。  

尽量不要使用synchronized(String a) 因为JVM中，字符串常量池具有缓存功能！

## 21. volatile关键字的特点 
- **保证了变量的可见性**（visibility）。被volatile关键字修饰的变量，如果值发生了变更，其他线程立马可见，避免出现脏读的现象。只有用于修饰成员变量。    

- **禁止指令重排序**（JVM或CPU为保证效率并不一定会按顺序执行指令）  

- **不保证原子性（不保证多线程安全）**  

## 22. 谈谈`synchronized`和`ReentrantLock` 的区别  
- 两者都是可重入锁  

- synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API  

-  ReentrantLock 比 synchronized 增加了一些高级功能

## 23.  并发编程的三个重要特性  
- 原子性 : 一个的操作或者多次操作，要么所有的操作全部都得到执行并且不会收到任何因素的干扰和中断，要么所有的操作都执行，要么都不执行。`synchronized `可以保证代码片段的原子性。  

- 可见性 ：当一个线程对共享变量进行了修改，另外的线程可以立即看到最新值。`volatile`可保证共享变量的可见性。  

- 有序性：代码在执行的过程中的先后顺序，Java 在编译器以及运行期间的优化，代码的执行顺序未必就是编写代码时候的顺序。`volatile `关键字可以禁止指令进行重排序优化。  

## 24. `synchronized` 关键字和 `volatile` 关键字的区别  
-  `synchronized`可用于修饰方法、代码块，而`volatile`只能用于修饰变量。  

- 多线程访问`volatile`关键字不会发生阻塞（不能保证多线程安全），而`synchronized`关键字可能会发生阻塞。  

- `volatile`关键字能保证数据的可见性，但不能保证数据的原子性。`synchronized`关键字两者都能保证。  

- `volatile`关键字用于解决变量在多线程之间的可见性，而`synchronized`关键字解决的是多线程之间访问资源的同步性。  

## 25. ThreadLocal简介  
`ThreadLocal` 类主要解决的就是让每个线程绑定自己的值，可以将 `ThreadLocal` 类形象的比喻成存放数据的盒子，盒子中可以**存储每个线程的私有数据**。  

## 26.  为什么要用线程池？  
池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。  
- **降低资源消耗**。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。  

- **提高响应速度**。当任务到达时，任务可以不需要的等到线程创建就能立即执行。  

- **提高线程的可管理性**。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。

## 27. `Atomic` 原子类  
-  

## 28. 程序计数器作用  
- 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的**流程控制**。（顺序、选择、循环、异常...）  

- 在多线程的情况下，程序计数器用于 **记录当前线程执行的位置**，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。  

程序计数器是唯一一个不会出现 `OutOfMemoryError` 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。

## 29. Java对象的创建过程  
- **类加载检查**： 虚拟机遇到一条` new `指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。  

- **分配内存**：在类加载检查通过后，接下来虚拟机将为新生对象分配内存。分
配方式有 “指针碰撞” 和 “空闲列表” 两种，选择那种分配方式由 Java 堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。  

- **初始化零值**： 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作**保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用**，程序能访问到这些字段的数据类型所对应的零值。 

- **设置对象头**： 初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。  

- **执行init方法**： 在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从Java 程序的视⻆来看，对象创建才刚开始，<init>  方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行  <init>  方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。    

## 30. 对象的访问定位有哪两种方式?  
- 句柄  

- 直接指针  

## 31. Minor GC和Full GC 有什么不同呢？  
大多数情况下，对象在新生代中 eden 区分配。当 eden 区没有足够空间进行分配时，虚拟机将发起一次Minor GC。   
-  **新生代GC(Minor GC)**：:指发生新生代的的垃圾收集动作，Minor GC非常频繁，回收速度一般也比较快。

- **老年代GC(Major GC/Full GC)**:指发生在老年代的GC，出现了Major GC经常会伴随至少一次的Minor GC（并非绝对），Major GC的速度一般会比Minor GC的慢10倍以上。

## 32. 如何判断对象是否死亡?(两种方法)
- **引用计数法**  

  给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1；当引用失效，计数器就减1；任何时候计数器为0的对象就是不可能再被使用的。 

- **可达性分析算法**  

  通过一系列的称为 **“GC Roots”**的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。

## 33. 如何判断一个常量是废弃常量?   
**运行时常量池**主要回收的是废弃的常量。  

假如常量池中存在的常量当前没有任何对象引用指向它就说明它是废弃常量。如果这时发生内存回收的话而且有必要的话，废弃常量就会被系统清理出常量池。

## 34.  如何判断一个类是无用的类?
**方法区**主要回收的是无用的类。  

判定一个类是否为“无用类”条件比较苛刻。必须要同时满足以下三个条件：  
- 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。  

- 加载该类的` ClassLoader `已经被回收。  

- 该类对应的` java.lang.Class `对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

## 35. 

## 36. 
## 37. 
## 38. 
## 39. 

